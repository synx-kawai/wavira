<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Multi-Zone Crowd Monitor</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
:root {
    --bg-primary: #0d1117;
    --bg-secondary: #161b22;
    --bg-tertiary: #21262d;
    --border-color: #30363d;
    --text-primary: #f0f6fc;
    --text-secondary: #8b949e;
    --accent-green: #3fb950;
    --accent-yellow: #d29922;
    --accent-orange: #db6d28;
    --accent-red: #f85149;
    --accent-blue: #58a6ff;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    background: var(--bg-primary);
    color: var(--text-primary);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    min-height: 100vh;
}

.app {
    max-width: 1400px;
    margin: 0 auto;
    padding: 16px;
}

/* Header */
.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 16px;
}

.header-title {
    font-size: 24px;
    font-weight: 600;
}

.header-status {
    display: flex;
    align-items: center;
    gap: 16px;
}

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--accent-red);
}

.status-dot.connected { background: var(--accent-green); }

/* Summary Card */
.summary-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 16px;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
}

.summary-item {
    text-align: center;
}

.summary-value {
    font-size: 48px;
    font-weight: 700;
}

.summary-value.green { color: var(--accent-green); }
.summary-value.yellow { color: var(--accent-yellow); }
.summary-value.red { color: var(--accent-red); }

.summary-label {
    color: var(--text-secondary);
    font-size: 14px;
    margin-top: 4px;
}

/* Zone Grid */
.zone-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 16px;
}

/* Zone Card */
.zone-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    transition: border-color 0.3s;
}

.zone-card.alert {
    border-color: var(--accent-red);
    animation: alert-pulse 1s infinite;
}

@keyframes alert-pulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(248, 81, 73, 0.4); }
    50% { box-shadow: 0 0 0 10px rgba(248, 81, 73, 0); }
}

.zone-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.zone-name {
    font-size: 18px;
    font-weight: 600;
}

.zone-status {
    padding: 4px 12px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 600;
}

.zone-status.empty { background: rgba(63, 185, 80, 0.2); color: var(--accent-green); }
.zone-status.low { background: rgba(88, 166, 255, 0.2); color: var(--accent-blue); }
.zone-status.medium { background: rgba(210, 153, 34, 0.2); color: var(--accent-yellow); }
.zone-status.high { background: rgba(248, 81, 73, 0.2); color: var(--accent-red); }

/* Capacity Bar */
.capacity-bar {
    height: 24px;
    background: var(--bg-tertiary);
    border-radius: 12px;
    overflow: hidden;
    margin: 12px 0;
    position: relative;
}

.capacity-fill {
    height: 100%;
    border-radius: 12px;
    transition: width 0.5s ease, background 0.3s;
}

.capacity-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 12px;
    font-weight: 600;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

/* Device List */
.device-list {
    margin-top: 16px;
}

.device-item {
    display: flex;
    align-items: center;
    padding: 10px;
    background: var(--bg-tertiary);
    border-radius: 6px;
    margin-bottom: 8px;
}

.device-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 12px;
}

.device-indicator.offline { background: var(--accent-red); }

.device-info {
    flex: 1;
}

.device-name {
    font-weight: 500;
}

.device-meta {
    font-size: 12px;
    color: var(--text-secondary);
}

.device-status {
    text-align: right;
}

.device-presence {
    font-size: 14px;
    font-weight: 600;
}

.device-presence.present { color: var(--accent-green); }
.device-presence.absent { color: var(--text-secondary); }

/* Floor Map */
.floor-map-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    margin-top: 16px;
}

.floor-map {
    position: relative;
    height: 300px;
    background: var(--bg-tertiary);
    border-radius: 8px;
    overflow: hidden;
}

.map-device {
    position: absolute;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transform: translate(-50%, -50%);
    border: 3px solid;
    background: var(--bg-secondary);
    transition: all 0.3s;
}

.map-device.present {
    animation: map-pulse 2s infinite;
}

@keyframes map-pulse {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.1); }
}

.map-device-icon {
    font-size: 20px;
}

.map-device-name {
    font-size: 10px;
    margin-top: 2px;
}

/* Alert Banner */
.alert-banner {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    padding: 12px 16px;
    background: var(--accent-red);
    color: white;
    text-align: center;
    font-weight: 600;
    transform: translateY(-100%);
    transition: transform 0.3s ease;
    z-index: 1000;
}

.alert-banner.visible {
    transform: translateY(0);
}

/* Signal Graphs Section */
.signal-section {
    margin-top: 16px;
}

.signal-section-title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.device-graphs-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 16px;
}

.device-graph-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 16px;
}

.device-graph-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
}

.device-graph-title {
    display: flex;
    align-items: center;
    gap: 8px;
}

.device-graph-title .indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
}

.device-graph-title .name {
    font-weight: 600;
}

.device-graph-stats {
    display: flex;
    gap: 16px;
    font-size: 12px;
    color: var(--text-secondary);
}

.device-graph-stats .stat-value {
    font-weight: 600;
    color: var(--text-primary);
}

.graph-container {
    position: relative;
    height: 120px;
    background: var(--bg-tertiary);
    border-radius: 6px;
    overflow: hidden;
    margin-bottom: 8px;
}

.graph-container canvas {
    width: 100%;
    height: 100%;
}

.graph-label {
    position: absolute;
    top: 4px;
    left: 8px;
    font-size: 10px;
    color: var(--text-secondary);
    background: rgba(0,0,0,0.5);
    padding: 2px 6px;
    border-radius: 3px;
}

.graph-legend {
    display: flex;
    justify-content: center;
    gap: 20px;
    font-size: 12px;
    color: var(--text-primary);
    padding: 8px;
    background: var(--bg-tertiary);
    border-radius: 6px;
    margin-top: 8px;
}

.graph-legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
}

.graph-legend-item .line {
    width: 20px;
    height: 3px;
    border-radius: 2px;
}

.graph-legend-item .dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
}

/* CSI Waveform Mini */
.csi-waveform {
    height: 80px;
    background: var(--bg-tertiary);
    border-radius: 6px;
    margin-top: 8px;
}

/* Hourly Chart Section */
.hourly-section {
    margin-top: 16px;
}

.hourly-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
}

.hourly-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.hourly-title {
    font-size: 18px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
}

.hourly-controls {
    display: flex;
    gap: 10px;
    align-items: center;
}

.hourly-controls select {
    padding: 6px 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    background: var(--bg-tertiary);
    color: var(--text-primary);
    font-size: 14px;
}

.hourly-chart-container {
    position: relative;
    height: 250px;
}

.hourly-legend {
    display: flex;
    justify-content: center;
    gap: 24px;
    margin-top: 12px;
    font-size: 13px;
    color: var(--text-secondary);
}

.hourly-legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
}

.hourly-legend-item .bar {
    width: 16px;
    height: 12px;
    border-radius: 2px;
}

.history-link {
    color: var(--accent-blue);
    text-decoration: none;
    font-size: 14px;
}

.history-link:hover {
    text-decoration: underline;
}
</style>
</head>
<body>

<div class="alert-banner" id="alertBanner">
    ‚ö†Ô∏è Ê∑∑Èõë„Ç®„É™„Ç¢„Åå„ÅÇ„Çä„Åæ„Åô
</div>

<div class="app">
    <header class="header">
        <h1 class="header-title">üè¢ Multi-Zone Crowd Monitor</h1>
        <div class="header-status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Êé•Á∂ö‰∏≠...</span>
            <span>„Éá„Éê„Ç§„Çπ: <span id="deviceCount">0</span></span>
        </div>
    </header>

    <!-- Summary -->
    <div class="summary-card">
        <div class="summary-item">
            <div class="summary-value green" id="totalPresent">0</div>
            <div class="summary-label">Ê§úÂá∫‰∫∫Êï∞ÔºàÂêàË®àÔºâ</div>
        </div>
        <div class="summary-item">
            <div class="summary-value" id="activeZones">0</div>
            <div class="summary-label">„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Çæ„Éº„É≥</div>
        </div>
        <div class="summary-item">
            <div class="summary-value" id="onlineDevices">0</div>
            <div class="summary-label">„Ç™„É≥„É©„Ç§„É≥„Éá„Éê„Ç§„Çπ</div>
        </div>
        <div class="summary-item">
            <div class="summary-value" id="alertZones">0</div>
            <div class="summary-label">Ê∑∑Èõë„Ç¢„É©„Éº„Éà</div>
        </div>
    </div>

    <!-- Zone Cards -->
    <div class="zone-grid" id="zoneGrid">
        <!-- Zones will be dynamically added here -->
    </div>

    <!-- Signal Graphs Section -->
    <div class="signal-section">
        <div class="signal-section-title">
            üìä „Éá„Éê„Ç§„ÇπÂà•ÈõªÊ≥¢Áä∂Ê≥ÅÔºà„É™„Ç¢„É´„Çø„Ç§„É†Ôºâ
        </div>
        <div class="device-graphs-grid" id="deviceGraphsGrid">
            <!-- Device graphs will be dynamically added here -->
        </div>
    </div>

    <!-- Hourly Average Section -->
    <div class="hourly-section">
        <div class="hourly-card">
            <div class="hourly-header">
                <div class="hourly-title">
                    üìä ÊôÇÈñìÂ∏ØÂà•Âπ≥Âùá
                </div>
                <div class="hourly-controls">
                    <select id="hourlyPeriod" onchange="loadHourlyData()">
                        <option value="6">ÈÅéÂéª6ÊôÇÈñì</option>
                        <option value="12">ÈÅéÂéª12ÊôÇÈñì</option>
                        <option value="24" selected>ÈÅéÂéª24ÊôÇÈñì</option>
                        <option value="48">ÈÅéÂéª48ÊôÇÈñì</option>
                    </select>
                    <a href="history.html" class="history-link">Ë©≥Á¥∞Â±•Ê≠¥ ‚Üí</a>
                </div>
            </div>
            <div class="hourly-chart-container">
                <canvas id="hourlyChart"></canvas>
            </div>
        </div>
    </div>

    <!-- Floor Map -->
    <div class="floor-map-card">
        <h3 style="margin-bottom: 16px;">„Éï„É≠„Ç¢„Éû„ÉÉ„Éó</h3>
        <div class="floor-map" id="floorMap">
            <!-- Devices will be dynamically added here -->
        </div>
    </div>
</div>

<script>
// Constants
const HISTORY_LENGTH = 120; // 2 minutes at 1 sample/sec
const GRAPH_UPDATE_INTERVAL = 100; // ms

// State
let connected = false;
let devices = {};
let zones = {};
let deviceHistory = {}; // { deviceId: { rssi: [], amplitude: [], breathRatio: [], timestamps: [] } }
let deviceCanvases = {}; // { deviceId: { signal: canvas, waveform: canvas } }
let wsConnection = null;
let hourlyChart = null;

// Connect to WebSocket
function connect() {
    // Use Cloudflare tunnel for production, local for development
    let wsUrl;
    if (window.location.hostname === 'localhost') {
        wsUrl = 'ws://localhost:8765';
    } else {
        // Use secure WebSocket through Cloudflare tunnel
        wsUrl = `wss://${window.location.hostname}/ws`;
    }
    const ws = new WebSocket(wsUrl);
    wsConnection = ws;

    ws.onopen = () => {
        connected = true;
        document.getElementById('statusDot').classList.add('connected');
        document.getElementById('statusText').textContent = 'Êé•Á∂öÊ∏à„Åø';
        // Load hourly data on connect
        loadHourlyData();
    };

    ws.onclose = () => {
        connected = false;
        wsConnection = null;
        document.getElementById('statusDot').classList.remove('connected');
        document.getElementById('statusText').textContent = 'ÂÜçÊé•Á∂ö‰∏≠...';
        setTimeout(connect, 2000);
    };

    ws.onmessage = (e) => {
        try {
            const data = JSON.parse(e.data);
            if (data.type === 'status') {
                updateStatus(data);
            } else if (data.type === 'hourly_summary') {
                displayHourlySummary(data.data);
            } else if (data.type === 'history') {
                // Â±•Ê≠¥„Éá„Éº„Çø„ÇíÂèó‰ø°„Åó„Å¶„Ç∞„É©„Éï„ÇíÂæ©ÂÖÉ
                restoreHistoryData(data);
            } else if (data.device_id) {
                updateDevice(data);
            }
        } catch (err) {
            console.error('Parse error:', err);
        }
    };
}

// Update status from server
function updateStatus(status) {
    if (status.devices) {
        status.devices.forEach(dev => {
            devices[dev.id] = { ...devices[dev.id], ...dev };
        });
    }

    if (status.zones) {
        zones = status.zones;
        renderZones();
    }

    updateSummary();
    ensureDeviceGraphCards();
}

// Restore history data from server (called on reconnect)
function restoreHistoryData(historyMsg) {
    const deviceId = historyMsg.device_id;
    const historyData = historyMsg.data;

    if (!historyData || historyData.length === 0) return;

    console.log(`Restoring ${historyData.length} history entries for ${deviceId}`);

    // Initialize device if not exists
    if (!devices[deviceId]) {
        const firstEntry = historyData[0];
        devices[deviceId] = {
            id: deviceId,
            name: firstEntry.device_name || deviceId,
            zone: firstEntry.zone || 'default',
            color: firstEntry.color || '#3fb950',
            connected: true,
        };
    }

    // Initialize history arrays
    if (!deviceHistory[deviceId]) {
        deviceHistory[deviceId] = {
            rssi: [],
            amplitude: [],
            breathRatio: [],
            timestamps: []
        };
    }

    const hist = deviceHistory[deviceId];

    // Clear existing history and restore from server data
    hist.rssi = [];
    hist.amplitude = [];
    hist.breathRatio = [];
    hist.timestamps = [];

    historyData.forEach(entry => {
        const avgAmp = entry.amps && entry.amps.length > 0
            ? entry.amps.reduce((a, b) => a + b, 0) / entry.amps.length
            : 0;

        hist.rssi.push(entry.rssi || -100);
        hist.amplitude.push(avgAmp);
        hist.breathRatio.push((entry.breath?.breath_ratio || 0) * 100);
        // Convert server timestamp to milliseconds if needed
        hist.timestamps.push(entry.timestamp ? entry.timestamp * 1000 : Date.now());
    });

    // Update device with latest data
    const lastEntry = historyData[historyData.length - 1];
    devices[deviceId].rssi = lastEntry.rssi;
    devices[deviceId].breath = lastEntry.breath;
    devices[deviceId].amps = lastEntry.amps;
    devices[deviceId].lastUpdate = Date.now();
    devices[deviceId].connected = true;

    // Update UI
    ensureDeviceGraphCards();
    updateSummary();

    // Force redraw graphs
    drawSignalGraph(deviceId);
    drawCSIGraph(deviceId);
}

// Update individual device data
function updateDevice(data) {
    const deviceId = data.device_id;
    const now = Date.now();

    if (!devices[deviceId]) {
        devices[deviceId] = {
            id: deviceId,
            name: data.device_name || deviceId,
            zone: data.zone || 'default',
            color: data.color || '#3fb950',
            connected: true,
        };
    }

    devices[deviceId].rssi = data.rssi;
    devices[deviceId].breath = data.breath;
    devices[deviceId].amps = data.amps;
    devices[deviceId].lastUpdate = now;
    devices[deviceId].connected = true;

    // Store history
    if (!deviceHistory[deviceId]) {
        deviceHistory[deviceId] = {
            rssi: [],
            amplitude: [],
            breathRatio: [],
            timestamps: []
        };
    }

    const hist = deviceHistory[deviceId];
    const avgAmp = data.amps ? data.amps.reduce((a, b) => a + b, 0) / data.amps.length : 0;

    hist.rssi.push(data.rssi || -100);
    hist.amplitude.push(avgAmp);
    hist.breathRatio.push((data.breath?.breath_ratio || 0) * 100);
    hist.timestamps.push(now);

    // Trim old data
    while (hist.timestamps.length > HISTORY_LENGTH) {
        hist.rssi.shift();
        hist.amplitude.shift();
        hist.breathRatio.shift();
        hist.timestamps.shift();
    }

    // Update zone presence
    const zoneId = devices[deviceId].zone;
    if (zones[zoneId]) {
        let present = 0;
        Object.values(devices).forEach(dev => {
            if (dev.zone === zoneId && dev.breath?.present) {
                present++;
            }
        });
        zones[zoneId].total_present = present;
    }

    renderZones();
    updateSummary();
    updateFloorMap();
    ensureDeviceGraphCards();
}

// Ensure device graph cards exist
function ensureDeviceGraphCards() {
    const grid = document.getElementById('deviceGraphsGrid');

    Object.values(devices).forEach(dev => {
        if (!document.getElementById(`graph-card-${dev.id}`)) {
            createDeviceGraphCard(dev, grid);
        }
        updateDeviceGraphCard(dev);
    });
}

// Create device graph card
function createDeviceGraphCard(dev, container) {
    const card = document.createElement('div');
    card.id = `graph-card-${dev.id}`;
    card.className = 'device-graph-card';

    card.innerHTML = `
        <div class="device-graph-header">
            <div class="device-graph-title">
                <div class="indicator" style="background: ${dev.color}"></div>
                <span class="name">${dev.name}</span>
            </div>
            <div class="device-graph-stats">
                <span>RSSI: <span class="stat-value" id="stat-rssi-${dev.id}">--</span> dBm</span>
                <span>ÊåØÂπÖ: <span class="stat-value" id="stat-amp-${dev.id}">--</span></span>
                <span>ÂëºÂê∏: <span class="stat-value" id="stat-breath-${dev.id}">--</span>%</span>
            </div>
        </div>
        <div class="graph-container">
            <canvas id="canvas-signal-${dev.id}"></canvas>
            <div class="graph-label">‰ø°Âè∑Âº∑Â∫¶ (2ÂàÜÈñì)</div>
        </div>
        <div class="graph-container" style="height: 80px;">
            <canvas id="canvas-waveform-${dev.id}"></canvas>
            <div class="graph-label">CSIÊ≥¢ÂΩ¢ („É™„Ç¢„É´„Çø„Ç§„É†)</div>
        </div>
        <div class="graph-legend">
            <div class="graph-legend-item">
                <div class="line" style="background: var(--accent-blue)"></div>
                <span>RSSI (ÈõªÊ≥¢Âº∑Â∫¶)</span>
            </div>
            <div class="graph-legend-item">
                <div class="line" style="background: var(--accent-green)"></div>
                <span>ÊåØÂπÖ (CSIÂ§âÂãï)</span>
            </div>
            <div class="graph-legend-item">
                <div class="line" style="background: var(--accent-yellow)"></div>
                <span>ÂëºÂê∏ÊØîÁéá</span>
            </div>
        </div>
    `;

    container.appendChild(card);

    // Setup canvases
    const signalCanvas = document.getElementById(`canvas-signal-${dev.id}`);
    const waveformCanvas = document.getElementById(`canvas-waveform-${dev.id}`);

    deviceCanvases[dev.id] = {
        signal: signalCanvas,
        waveform: waveformCanvas,
        signalCtx: signalCanvas.getContext('2d'),
        waveformCtx: waveformCanvas.getContext('2d')
    };

    // Set canvas size
    resizeCanvas(signalCanvas);
    resizeCanvas(waveformCanvas);
}

// Resize canvas to match container
function resizeCanvas(canvas) {
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
}

// Update device graph card stats
function updateDeviceGraphCard(dev) {
    const rssiEl = document.getElementById(`stat-rssi-${dev.id}`);
    const ampEl = document.getElementById(`stat-amp-${dev.id}`);
    const breathEl = document.getElementById(`stat-breath-${dev.id}`);

    if (rssiEl) rssiEl.textContent = dev.rssi || '--';
    if (ampEl) {
        const avg = dev.amps ? (dev.amps.reduce((a, b) => a + b, 0) / dev.amps.length).toFixed(1) : '--';
        ampEl.textContent = avg;
    }
    if (breathEl) {
        breathEl.textContent = dev.breath?.breath_ratio ? (dev.breath.breath_ratio * 100).toFixed(0) : '--';
    }
}

// Draw signal history graph
function drawSignalGraph(deviceId) {
    const canvasInfo = deviceCanvases[deviceId];
    const hist = deviceHistory[deviceId];
    if (!canvasInfo || !hist || hist.timestamps.length < 2) return;

    const ctx = canvasInfo.signalCtx;
    const canvas = canvasInfo.signal;
    const w = canvas.width;
    const h = canvas.height;

    // Clear
    ctx.fillStyle = '#21262d';
    ctx.fillRect(0, 0, w, h);

    // Draw grid
    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 1;
    for (let i = 1; i < 4; i++) {
        const y = (h / 4) * i;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
    }

    const padding = 5;
    const plotW = w - padding * 2;
    const plotH = h - padding * 2;

    // Normalize and draw each metric
    const drawLine = (data, color, minVal, maxVal) => {
        if (data.length < 2) return;

        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();

        for (let i = 0; i < data.length; i++) {
            const x = padding + (i / (HISTORY_LENGTH - 1)) * plotW;
            const normalized = (data[i] - minVal) / (maxVal - minVal);
            const y = padding + plotH - normalized * plotH;

            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    };

    // RSSI: -100 to -30 dBm
    drawLine(hist.rssi, '#58a6ff', -100, -30);

    // Amplitude: 0 to 100
    const maxAmp = Math.max(...hist.amplitude, 100);
    drawLine(hist.amplitude, '#3fb950', 0, maxAmp);

    // Breath ratio: 0 to 100%
    drawLine(hist.breathRatio, '#d29922', 0, 100);
}

// Draw CSI waveform
function drawWaveform(deviceId) {
    const canvasInfo = deviceCanvases[deviceId];
    const dev = devices[deviceId];
    if (!canvasInfo || !dev?.amps) return;

    const ctx = canvasInfo.waveformCtx;
    const canvas = canvasInfo.waveform;
    const w = canvas.width;
    const h = canvas.height;

    // Clear
    ctx.fillStyle = '#21262d';
    ctx.fillRect(0, 0, w, h);

    const amps = dev.amps;
    if (amps.length < 2) return;

    // Find max for scaling
    const maxAmp = Math.max(...amps, 1);

    // Draw waveform
    const isPresent = dev.breath?.present;
    ctx.strokeStyle = isPresent ? '#3fb950' : '#58a6ff';
    ctx.lineWidth = 1.5;
    ctx.beginPath();

    const padding = 5;
    for (let i = 0; i < amps.length; i++) {
        const x = padding + (i / (amps.length - 1)) * (w - padding * 2);
        const y = padding + (h - padding * 2) - (amps[i] / maxAmp) * (h - padding * 2);

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Draw presence indicator
    if (isPresent) {
        ctx.fillStyle = 'rgba(63, 185, 80, 0.3)';
        ctx.fillRect(w - 30, 5, 25, 15);
        ctx.fillStyle = '#3fb950';
        ctx.font = '10px sans-serif';
        ctx.fillText('üë§', w - 25, 16);
    }
}

// Render zone cards
function renderZones() {
    const grid = document.getElementById('zoneGrid');

    Object.entries(zones).forEach(([zoneId, zone]) => {
        let card = document.getElementById(`zone-${zoneId}`);

        if (!card) {
            card = document.createElement('div');
            card.id = `zone-${zoneId}`;
            card.className = 'zone-card';
            grid.appendChild(card);
        }

        const present = zone.total_present || 0;
        const capacity = zone.capacity || 10;
        const ratio = present / capacity;

        let statusClass, statusText;
        if (present === 0) {
            statusClass = 'empty';
            statusText = 'Á©∫„Åç';
        } else if (ratio < 0.5) {
            statusClass = 'low';
            statusText = 'Â∞ë„Å™„ÅÑ';
        } else if (ratio < 0.8) {
            statusClass = 'medium';
            statusText = '„ÇÑ„ÇÑÊ∑∑Èõë';
        } else {
            statusClass = 'high';
            statusText = 'Ê∑∑Èõë';
        }

        if (present >= (zone.alert_threshold || capacity * 0.8)) {
            card.classList.add('alert');
        } else {
            card.classList.remove('alert');
        }

        let barColor;
        if (ratio < 0.5) barColor = 'var(--accent-green)';
        else if (ratio < 0.8) barColor = 'var(--accent-yellow)';
        else barColor = 'var(--accent-red)';

        const zoneDevices = Object.values(devices).filter(d => d.zone === zoneId);

        card.innerHTML = `
            <div class="zone-header">
                <span class="zone-name">${zone.name}</span>
                <span class="zone-status ${statusClass}">${statusText}</span>
            </div>
            <div class="capacity-bar">
                <div class="capacity-fill" style="width: ${Math.min(ratio * 100, 100)}%; background: ${barColor}"></div>
                <span class="capacity-text">${present} / ${capacity}</span>
            </div>
            <div class="device-list">
                ${zoneDevices.map(dev => `
                    <div class="device-item">
                        <div class="device-indicator" style="background: ${dev.connected ? dev.color : 'var(--accent-red)'}"></div>
                        <div class="device-info">
                            <div class="device-name">${dev.name}</div>
                            <div class="device-meta">RSSI: ${dev.rssi || '--'} dBm</div>
                        </div>
                        <div class="device-status">
                            <div class="device-presence ${dev.breath?.present ? 'present' : 'absent'}">
                                ${dev.breath?.present ? 'üë§ Ê§úÂá∫' : '-- Êú™Ê§úÂá∫'}
                            </div>
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
    });
}

// Update summary
function updateSummary() {
    let totalPresent = 0;
    let activeZones = 0;
    let onlineDevices = 0;
    let alertZones = 0;

    Object.values(zones).forEach(zone => {
        const present = zone.total_present || 0;
        totalPresent += present;
        if (present > 0) activeZones++;
        if (present >= (zone.alert_threshold || zone.capacity * 0.8)) alertZones++;
    });

    Object.values(devices).forEach(dev => {
        if (dev.connected) onlineDevices++;
    });

    document.getElementById('totalPresent').textContent = totalPresent;
    document.getElementById('activeZones').textContent = activeZones;
    document.getElementById('onlineDevices').textContent = onlineDevices;
    document.getElementById('alertZones').textContent = alertZones;
    document.getElementById('deviceCount').textContent = Object.keys(devices).length;

    const totalEl = document.getElementById('totalPresent');
    totalEl.className = 'summary-value';
    if (totalPresent === 0) totalEl.classList.add('green');
    else if (alertZones > 0) totalEl.classList.add('red');
    else totalEl.classList.add('yellow');

    const banner = document.getElementById('alertBanner');
    if (alertZones > 0) {
        banner.classList.add('visible');
    } else {
        banner.classList.remove('visible');
    }
}

// Update floor map
function updateFloorMap() {
    const map = document.getElementById('floorMap');

    Object.values(devices).forEach(dev => {
        let marker = document.getElementById(`map-${dev.id}`);

        if (!marker) {
            marker = document.createElement('div');
            marker.id = `map-${dev.id}`;
            marker.className = 'map-device';
            map.appendChild(marker);
        }

        const x = 50 + (dev.position?.x || 0) * 5;
        const y = 50 + (dev.position?.y || 0) * 5;
        marker.style.left = `${x}%`;
        marker.style.top = `${y}%`;
        marker.style.borderColor = dev.color;

        const isPresent = dev.breath?.present;
        marker.className = `map-device ${isPresent ? 'present' : ''}`;

        marker.innerHTML = `
            <span class="map-device-icon">${isPresent ? 'üë§' : 'üì°'}</span>
            <span class="map-device-name">${dev.name}</span>
        `;
    });
}

// Animation loop for graphs
function animateGraphs() {
    Object.keys(deviceCanvases).forEach(deviceId => {
        drawSignalGraph(deviceId);
        drawWaveform(deviceId);
    });
    requestAnimationFrame(animateGraphs);
}

// Handle window resize
window.addEventListener('resize', () => {
    Object.values(deviceCanvases).forEach(info => {
        resizeCanvas(info.signal);
        resizeCanvas(info.waveform);
    });
});

// Load hourly data from server
function loadHourlyData() {
    if (!wsConnection || wsConnection.readyState !== WebSocket.OPEN) return;

    const hours = parseInt(document.getElementById('hourlyPeriod').value);
    wsConnection.send(JSON.stringify({
        type: 'get_hourly_summary',
        hours: hours
    }));
}

// Display hourly summary chart
function displayHourlySummary(data) {
    if (!data || data.length === 0) {
        // Show empty state
        if (hourlyChart) {
            hourlyChart.destroy();
            hourlyChart = null;
        }
        return;
    }

    // Get selected period
    const selectedPeriod = parseInt(document.getElementById('hourlyPeriod').value);
    const currentHour = new Date().getHours();

    // Group by hour
    const hourlyData = {};
    for (const row of data) {
        const hour = row.hour.substring(11, 13) + ':00';
        if (!hourlyData[hour]) {
            hourlyData[hour] = [];
        }
        hourlyData[hour].push(row.avg_crowd_level * 100);
    }

    // Calculate which hours to display based on selected period
    const hours = [];
    const avgValues = [];
    const maxValues = [];

    // For periods <= 24 hours, show only relevant hours from current time backwards
    // For periods > 24 hours (48h, 168h), show all 24 hours in order (00:00-23:00)
    if (selectedPeriod > 24) {
        // Show full 24-hour range for multi-day periods
        for (let h = 0; h < 24; h++) {
            const hourStr = h.toString().padStart(2, '0') + ':00';
            hours.push(hourStr);

            if (hourlyData[hourStr]) {
                const values = hourlyData[hourStr];
                avgValues.push(values.reduce((a, b) => a + b, 0) / values.length);
                maxValues.push(Math.max(...values));
            } else {
                avgValues.push(0);
                maxValues.push(0);
            }
        }
    } else {
        // Show only relevant hours from current time backwards
        for (let i = selectedPeriod - 1; i >= 0; i--) {
            let h = (currentHour - i + 24) % 24;
            const hourStr = h.toString().padStart(2, '0') + ':00';
            hours.push(hourStr);

            if (hourlyData[hourStr]) {
                const values = hourlyData[hourStr];
                avgValues.push(values.reduce((a, b) => a + b, 0) / values.length);
                maxValues.push(Math.max(...values));
            } else {
                avgValues.push(0);
                maxValues.push(0);
            }
        }
    }

    // Destroy existing chart
    if (hourlyChart) {
        hourlyChart.destroy();
    }

    // Create new chart
    const ctx = document.getElementById('hourlyChart').getContext('2d');
    hourlyChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: hours,
            datasets: [
                {
                    label: 'Âπ≥Âùá',
                    data: avgValues,
                    backgroundColor: 'rgba(88, 166, 255, 0.6)',
                    borderColor: '#58a6ff',
                    borderWidth: 1
                },
                {
                    label: 'ÊúÄÂ§ß',
                    data: maxValues,
                    backgroundColor: 'rgba(248, 81, 73, 0.6)',
                    borderColor: '#f85149',
                    borderWidth: 1
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    title: {
                        display: true,
                        text: 'Ê∑∑ÈõëÁéá (%)',
                        color: '#8b949e'
                    },
                    grid: { color: '#30363d' },
                    ticks: { color: '#8b949e' }
                },
                x: {
                    grid: { color: '#30363d' },
                    ticks: { color: '#8b949e' }
                }
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: { color: '#e8e8e8' }
                }
            }
        }
    });
}

// Auto-refresh hourly data every 60 seconds
setInterval(() => {
    if (connected) {
        loadHourlyData();
    }
}, 60000);

// Initialize
connect();
animateGraphs();
</script>
</body>
</html>
