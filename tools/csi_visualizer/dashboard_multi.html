<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Multi-Zone Crowd Monitor</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://unpkg.com/mqtt@5.3.4/dist/mqtt.min.js"></script>
<style>
:root {
    --bg-primary: #0d1117;
    --bg-secondary: #161b22;
    --bg-tertiary: #21262d;
    --border-color: #30363d;
    --text-primary: #f0f6fc;
    --text-secondary: #8b949e;
    --accent-green: #3fb950;
    --accent-yellow: #d29922;
    --accent-orange: #db6d28;
    --accent-red: #f85149;
    --accent-blue: #58a6ff;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    background: var(--bg-primary);
    color: var(--text-primary);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    min-height: 100vh;
}

.app {
    max-width: 1400px;
    margin: 0 auto;
    padding: 16px;
}

/* Header */
.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 16px;
}

.header-title {
    font-size: 24px;
    font-weight: 600;
}

.header-status {
    display: flex;
    align-items: center;
    gap: 16px;
}

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--accent-red);
}

.status-dot.connected { background: var(--accent-green); }

/* Summary Card */
.summary-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 16px;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
}

.summary-item {
    text-align: center;
}

.summary-value {
    font-size: 48px;
    font-weight: 700;
}

.summary-value.green { color: var(--accent-green); }
.summary-value.yellow { color: var(--accent-yellow); }
.summary-value.red { color: var(--accent-red); }

.summary-label {
    color: var(--text-secondary);
    font-size: 14px;
    margin-top: 4px;
}

/* Zone Grid */
.zone-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 16px;
}

/* Zone Card */
.zone-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    transition: border-color 0.3s;
}

.zone-card.alert {
    border-color: var(--accent-red);
    animation: alert-pulse 1s infinite;
}

@keyframes alert-pulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(248, 81, 73, 0.4); }
    50% { box-shadow: 0 0 0 10px rgba(248, 81, 73, 0); }
}

.zone-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.zone-name {
    font-size: 18px;
    font-weight: 600;
}

.zone-status {
    padding: 4px 12px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 600;
}

.zone-status.empty { background: rgba(63, 185, 80, 0.2); color: var(--accent-green); }
.zone-status.low { background: rgba(88, 166, 255, 0.2); color: var(--accent-blue); }
.zone-status.medium { background: rgba(210, 153, 34, 0.2); color: var(--accent-yellow); }
.zone-status.high { background: rgba(248, 81, 73, 0.2); color: var(--accent-red); }

/* Capacity Bar */
.capacity-bar {
    height: 24px;
    background: var(--bg-tertiary);
    border-radius: 12px;
    overflow: hidden;
    margin: 12px 0;
    position: relative;
}

.capacity-fill {
    height: 100%;
    border-radius: 12px;
    transition: width 0.5s ease, background 0.3s;
}

.capacity-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 12px;
    font-weight: 600;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

/* Device List */
.device-list {
    margin-top: 16px;
}

.device-item {
    display: flex;
    align-items: center;
    padding: 10px;
    background: var(--bg-tertiary);
    border-radius: 6px;
    margin-bottom: 8px;
}

.device-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 12px;
}

.device-indicator.offline { background: var(--accent-red); }

.device-info {
    flex: 1;
}

.device-name {
    font-weight: 500;
}

.device-meta {
    font-size: 12px;
    color: var(--text-secondary);
}

.device-status {
    text-align: right;
}

.device-presence {
    font-size: 14px;
    font-weight: 600;
}

.device-presence.present { color: var(--accent-green); }
.device-presence.absent { color: var(--text-secondary); }

/* Floor Map */
.floor-map-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    margin-top: 16px;
}

.floor-map {
    position: relative;
    height: 300px;
    background: var(--bg-tertiary);
    border-radius: 8px;
    overflow: hidden;
}

.map-device {
    position: absolute;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transform: translate(-50%, -50%);
    border: 3px solid;
    background: var(--bg-secondary);
    transition: all 0.3s;
}

.map-device.present {
    animation: map-pulse 2s infinite;
}

@keyframes map-pulse {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.1); }
}

.map-device-icon {
    font-size: 20px;
}

.map-device-name {
    font-size: 10px;
    margin-top: 2px;
}

/* Alert Banner */
.alert-banner {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    padding: 12px 16px;
    background: var(--accent-red);
    color: white;
    text-align: center;
    font-weight: 600;
    transform: translateY(-100%);
    transition: transform 0.3s ease;
    z-index: 1000;
}

.alert-banner.visible {
    transform: translateY(0);
}

/* Signal Graphs Section */
.signal-section {
    margin-top: 16px;
}

.signal-section-title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.device-graphs-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 16px;
}

.device-graph-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 16px;
}

.device-graph-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
}

.device-graph-title {
    display: flex;
    align-items: center;
    gap: 8px;
}

.device-graph-title .indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
}

.device-graph-title .name {
    font-weight: 600;
}

.device-graph-stats {
    display: flex;
    gap: 16px;
    font-size: 12px;
    color: var(--text-secondary);
}

.device-graph-stats .stat-value {
    font-weight: 600;
    color: var(--text-primary);
}

.graph-container {
    position: relative;
    height: 120px;
    background: var(--bg-tertiary);
    border-radius: 6px;
    overflow: hidden;
    margin-bottom: 8px;
}

.graph-container canvas {
    width: 100%;
    height: 100%;
}

.graph-label {
    position: absolute;
    top: 4px;
    left: 8px;
    font-size: 10px;
    color: var(--text-secondary);
    background: rgba(0,0,0,0.5);
    padding: 2px 6px;
    border-radius: 3px;
}

.graph-legend {
    display: flex;
    justify-content: center;
    gap: 20px;
    font-size: 12px;
    color: var(--text-primary);
    padding: 8px;
    background: var(--bg-tertiary);
    border-radius: 6px;
    margin-top: 8px;
}

.graph-legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
}

.graph-legend-item .line {
    width: 20px;
    height: 3px;
    border-radius: 2px;
}

.graph-legend-item .dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
}

/* CSI Waveform Mini */
.csi-waveform {
    height: 80px;
    background: var(--bg-tertiary);
    border-radius: 6px;
    margin-top: 8px;
}

/* Hourly Chart Section */
.hourly-section {
    margin-top: 16px;
}

.hourly-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
}

.hourly-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.hourly-title {
    font-size: 18px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
}

.hourly-controls {
    display: flex;
    gap: 10px;
    align-items: center;
}

.hourly-controls select {
    padding: 6px 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    background: var(--bg-tertiary);
    color: var(--text-primary);
    font-size: 14px;
}

.hourly-chart-container {
    position: relative;
    height: 250px;
}

.hourly-legend {
    display: flex;
    justify-content: center;
    gap: 24px;
    margin-top: 12px;
    font-size: 13px;
    color: var(--text-secondary);
}

.hourly-legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
}

.hourly-legend-item .bar {
    width: 16px;
    height: 12px;
    border-radius: 2px;
}

.history-link {
    color: var(--accent-blue);
    text-decoration: none;
    font-size: 14px;
}

.history-link:hover {
    text-decoration: underline;
}

/* Performance Monitor */
.perf-monitor {
    position: fixed;
    top: 60px;
    right: 16px;
    background: rgba(22, 27, 34, 0.95);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px 16px;
    font-family: 'Monaco', 'Menlo', monospace;
    font-size: 12px;
    z-index: 1001;
    min-width: 220px;
    display: none;
}

.perf-monitor.visible {
    display: block;
}

.perf-monitor-title {
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--accent-blue);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.perf-monitor-row {
    display: flex;
    justify-content: space-between;
    padding: 4px 0;
    border-bottom: 1px solid var(--border-color);
}

.perf-monitor-row:last-child {
    border-bottom: none;
}

.perf-monitor-label {
    color: var(--text-secondary);
}

.perf-monitor-value {
    font-weight: 600;
    min-width: 80px;
    text-align: right;
}

.perf-monitor-value.good { color: var(--accent-green); }
.perf-monitor-value.warn { color: var(--accent-yellow); }
.perf-monitor-value.bad { color: var(--accent-red); }

.perf-toggle {
    position: fixed;
    top: 16px;
    right: 16px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 8px 12px;
    color: var(--text-primary);
    cursor: pointer;
    font-size: 12px;
    z-index: 1002;
}

.perf-toggle:hover {
    background: var(--border-color);
}
</style>
</head>
<body>

<div class="alert-banner" id="alertBanner">
    ‚ö†Ô∏è Ê∑∑Èõë„Ç®„É™„Ç¢„Åå„ÅÇ„Çä„Åæ„Åô
</div>

<!-- Performance Monitor Toggle -->
<button class="perf-toggle" id="perfToggleBtn">üìä Perf</button>

<!-- Performance Monitor Panel -->
<div class="perf-monitor" id="perfMonitor">
    <div class="perf-monitor-title">
        <span>Performance Monitor</span>
        <span id="perfOptimized" style="font-size: 10px; color: var(--accent-yellow);">ORIGINAL</span>
    </div>
    <div class="perf-monitor-row">
        <span class="perf-monitor-label">FPS</span>
        <span class="perf-monitor-value" id="perfFps">--</span>
    </div>
    <div class="perf-monitor-row">
        <span class="perf-monitor-label">ÊèèÁîªÊôÇÈñì</span>
        <span class="perf-monitor-value" id="perfDrawTime">-- ms</span>
    </div>
    <div class="perf-monitor-row">
        <span class="perf-monitor-label">ÊèèÁîªÂõûÊï∞/Áßí</span>
        <span class="perf-monitor-value" id="perfDrawCalls">--</span>
    </div>
    <div class="perf-monitor-row">
        <span class="perf-monitor-label">ÁÑ°ÈßÑ„Å™ÊèèÁîª</span>
        <span class="perf-monitor-value" id="perfWastedDraws">--</span>
    </div>
    <div class="perf-monitor-row">
        <span class="perf-monitor-label">Long Tasks</span>
        <span class="perf-monitor-value" id="perfLongTasks">--</span>
    </div>
    <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid var(--border-color);">
        <button onclick="exportPerfData()" style="width: 100%; padding: 6px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); cursor: pointer;">
            üìã ÁµêÊûú„Çí„Ç≥„Éî„Éº
        </button>
    </div>
</div>

<div class="app">
    <header class="header">
        <h1 class="header-title">üè¢ Multi-Zone Crowd Monitor</h1>
        <div class="header-status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Êé•Á∂ö‰∏≠...</span>
            <span>„Éá„Éê„Ç§„Çπ: <span id="deviceCount">0</span></span>
        </div>
    </header>

    <!-- Summary -->
    <div class="summary-card">
        <div class="summary-item">
            <div class="summary-value green" id="totalPresent">0</div>
            <div class="summary-label">Ê§úÂá∫‰∫∫Êï∞ÔºàÂêàË®àÔºâ</div>
        </div>
        <div class="summary-item">
            <div class="summary-value" id="activeZones">0</div>
            <div class="summary-label">„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Çæ„Éº„É≥</div>
        </div>
        <div class="summary-item">
            <div class="summary-value" id="onlineDevices">0</div>
            <div class="summary-label">„Ç™„É≥„É©„Ç§„É≥„Éá„Éê„Ç§„Çπ</div>
        </div>
        <div class="summary-item">
            <div class="summary-value" id="alertZones">0</div>
            <div class="summary-label">Ê∑∑Èõë„Ç¢„É©„Éº„Éà</div>
        </div>
    </div>

    <!-- Zone Cards -->
    <div class="zone-grid" id="zoneGrid">
        <!-- Zones will be dynamically added here -->
    </div>

    <!-- Signal Graphs Section -->
    <div class="signal-section">
        <div class="signal-section-title">
            üìä „Éá„Éê„Ç§„ÇπÂà•ÈõªÊ≥¢Áä∂Ê≥ÅÔºà„É™„Ç¢„É´„Çø„Ç§„É†Ôºâ
        </div>
        <div class="device-graphs-grid" id="deviceGraphsGrid">
            <!-- Device graphs will be dynamically added here -->
        </div>
    </div>

    <!-- Hourly Average Section -->
    <div class="hourly-section">
        <div class="hourly-card">
            <div class="hourly-header">
                <div class="hourly-title">
                    üìä ÊôÇÈñìÂ∏ØÂà•Âπ≥Âùá
                </div>
                <div class="hourly-controls">
                    <select id="hourlyPeriod" onchange="loadHourlyData()">
                        <option value="6">ÈÅéÂéª6ÊôÇÈñì</option>
                        <option value="12">ÈÅéÂéª12ÊôÇÈñì</option>
                        <option value="24" selected>ÈÅéÂéª24ÊôÇÈñì</option>
                        <option value="48">ÈÅéÂéª48ÊôÇÈñì</option>
                    </select>
                    <a href="history.html" class="history-link">Ë©≥Á¥∞Â±•Ê≠¥ ‚Üí</a>
                </div>
            </div>
            <div class="hourly-chart-container">
                <canvas id="hourlyChart"></canvas>
            </div>
        </div>
    </div>

    <!-- Floor Map -->
    <div class="floor-map-card">
        <h3 style="margin-bottom: 16px;">„Éï„É≠„Ç¢„Éû„ÉÉ„Éó</h3>
        <div class="floor-map" id="floorMap">
            <!-- Devices will be dynamically added here -->
        </div>
    </div>
</div>

<script>
// Constants
const HISTORY_LENGTH = 120; // 2 minutes at 1 sample/sec
const GRAPH_UPDATE_INTERVAL = 100; // ms

// State
let connected = false;
let devices = {};
let zones = {};
let deviceHistory = {}; // { deviceId: { rssi: [], amplitude: [], breathRatio: [], timestamps: [] } }
let deviceCanvases = {}; // { deviceId: { signal: canvas, waveform: canvas } }
let mqttClient = null;
let hourlyChart = null;

// Get MQTT URL based on environment
function getMqttUrl() {
    const urlParams = new URLSearchParams(window.location.search);
    const mqttParam = urlParams.get('mqtt');
    if (mqttParam) {
        return mqttParam.startsWith('ws') ? mqttParam : `ws://${mqttParam}`;
    }
    const hostname = window.location.hostname;
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return 'ws://localhost:9001';
    }
    return `wss://${hostname}:9001/mqtt`;
}

// Get API URL for historical data
function getApiUrl() {
    const hostname = window.location.hostname;
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return 'http://localhost:8080';
    }
    return `${window.location.protocol}//${hostname}/api`;
}

// Connect to MQTT broker
function connect() {
    const mqttUrl = getMqttUrl();
    console.log('Connecting to MQTT:', mqttUrl);

    mqttClient = mqtt.connect(mqttUrl, {
        clientId: 'wavira-dashboard-' + Math.random().toString(16).substr(2, 8),
        keepalive: 30,
        clean: true,
        reconnectPeriod: 2000,
    });

    mqttClient.on('connect', () => {
        connected = true;
        document.getElementById('statusDot').classList.add('connected');
        document.getElementById('statusText').textContent = 'Êé•Á∂öÊ∏à„Åø';

        // Subscribe to analysis data
        mqttClient.subscribe('wavira/analysis/#', { qos: 0 });
        mqttClient.subscribe('wavira/device/+/status', { qos: 1 });
        console.log('Subscribed to MQTT topics');

        // Load hourly data via REST API
        loadHourlyData();
        // Load known devices
        loadDevices();
    });

    mqttClient.on('close', () => {
        connected = false;
        document.getElementById('statusDot').classList.remove('connected');
        document.getElementById('statusText').textContent = 'ÂÜçÊé•Á∂ö‰∏≠...';
    });

    mqttClient.on('error', (err) => {
        console.error('MQTT error:', err);
    });

    mqttClient.on('message', (topic, message) => {
        try {
            const data = JSON.parse(message.toString());

            // Handle analysis data (main device data)
            if (topic.startsWith('wavira/analysis/') && !topic.endsWith('/presence') && !topic.endsWith('/breathing')) {
                // Convert MQTT format to expected format
                const deviceData = {
                    device_id: data.device_id,
                    device_name: data.device_id,
                    zone: 'default',
                    color: getDeviceColor(data.device_id),
                    rssi: data.rssi,
                    amps: data.amps || [],
                    breath: {
                        present: data.present,
                        breath_ratio: data.breath_ratio,
                        breathing: data.breathing,
                        breath_rate: data.breathing_rate
                    }
                };
                updateDevice(deviceData);
            }
            // Handle device status
            else if (topic.startsWith('wavira/device/') && topic.endsWith('/status')) {
                const deviceId = topic.split('/')[2];
                console.log('Device status:', deviceId, data);
            }
        } catch (err) {
            console.debug('Parse error:', err);
        }
    });
}

// Get color for device based on index
function getDeviceColor(deviceId) {
    const colors = ['#3fb950', '#58a6ff', '#d29922', '#f85149', '#a371f7', '#79c0ff'];
    const index = Object.keys(devices).indexOf(deviceId);
    return colors[index >= 0 ? index % colors.length : Object.keys(devices).length % colors.length];
}

// Load devices from REST API
async function loadDevices() {
    try {
        const response = await fetch(`${getApiUrl()}/api/v1/devices`);
        if (!response.ok) return;
        const deviceList = await response.json();
        for (const dev of deviceList) {
            if (!devices[dev.device_id]) {
                devices[dev.device_id] = {
                    id: dev.device_id,
                    name: dev.device_id,
                    zone: dev.zone || 'default',
                    color: getDeviceColor(dev.device_id),
                    connected: dev.online,
                    rssi: dev.rssi
                };
            }
            // Load history for this device
            await loadDeviceHistory(dev.device_id);
        }
        ensureDeviceGraphCards();
        updateSummary();

        // Trigger initial draw for OPTIMIZED mode
        if (USE_OPTIMIZED) {
            Object.keys(deviceCanvases).forEach(markDeviceDirty);
            scheduleRedraw();
        }
    } catch (e) {
        console.warn('Failed to load devices:', e);
    }
}

// Load recent history for a device from REST API
async function loadDeviceHistory(deviceId) {
    try {
        // Load last 120 records (2 minutes at ~1 sample/sec)
        const response = await fetch(`${getApiUrl()}/api/v1/history/${deviceId}?limit=${HISTORY_LENGTH}`);
        if (!response.ok) return;
        const historyData = await response.json();

        if (!historyData || historyData.length === 0) return;

        console.log(`Loaded ${historyData.length} history entries for ${deviceId}`);

        // Initialize history arrays
        if (!deviceHistory[deviceId]) {
            deviceHistory[deviceId] = {
                rssi: [],
                amplitude: [],
                breathRatio: [],
                timestamps: []
            };
        }

        const hist = deviceHistory[deviceId];

        // Clear and restore from server data
        hist.rssi = [];
        hist.amplitude = [];
        hist.breathRatio = [];
        hist.timestamps = [];

        // historyData is already sorted by timestamp ASC from the API
        historyData.forEach(entry => {
            hist.rssi.push(entry.rssi || -100);
            hist.amplitude.push(entry.avg_amplitude || 0);
            hist.breathRatio.push((entry.breath_ratio || 0) * 100);
            hist.timestamps.push(entry.timestamp * 1000); // Convert to milliseconds
        });

        // Update device with latest data
        if (historyData.length > 0) {
            const lastEntry = historyData[historyData.length - 1];
            devices[deviceId].rssi = lastEntry.rssi;
            devices[deviceId].breath = {
                present: lastEntry.present,
                breath_ratio: lastEntry.breath_ratio,
                breathing: lastEntry.breathing
            };
            devices[deviceId].lastUpdate = Date.now();
        }
    } catch (e) {
        console.warn(`Failed to load history for ${deviceId}:`, e);
    }
}

// Update status from server
function updateStatus(status) {
    if (status.devices) {
        status.devices.forEach(dev => {
            devices[dev.id] = { ...devices[dev.id], ...dev };
        });
    }

    if (status.zones) {
        zones = status.zones;
        renderZones();
    }

    updateSummary();
    ensureDeviceGraphCards();
}

// Restore history data from server (called on reconnect)
function restoreHistoryData(historyMsg) {
    const deviceId = historyMsg.device_id;
    const historyData = historyMsg.data;

    if (!historyData || historyData.length === 0) return;

    console.log(`Restoring ${historyData.length} history entries for ${deviceId}`);

    // Initialize device if not exists
    if (!devices[deviceId]) {
        const firstEntry = historyData[0];
        devices[deviceId] = {
            id: deviceId,
            name: firstEntry.device_name || deviceId,
            zone: firstEntry.zone || 'default',
            color: firstEntry.color || '#3fb950',
            connected: true,
        };
    }

    // Initialize history arrays
    if (!deviceHistory[deviceId]) {
        deviceHistory[deviceId] = {
            rssi: [],
            amplitude: [],
            breathRatio: [],
            timestamps: []
        };
    }

    const hist = deviceHistory[deviceId];

    // Clear existing history and restore from server data
    hist.rssi = [];
    hist.amplitude = [];
    hist.breathRatio = [];
    hist.timestamps = [];

    historyData.forEach(entry => {
        const avgAmp = entry.amps && entry.amps.length > 0
            ? entry.amps.reduce((a, b) => a + b, 0) / entry.amps.length
            : 0;

        hist.rssi.push(entry.rssi || -100);
        hist.amplitude.push(avgAmp);
        hist.breathRatio.push((entry.breath?.breath_ratio || 0) * 100);
        // Convert server timestamp to milliseconds if needed
        hist.timestamps.push(entry.timestamp ? entry.timestamp * 1000 : Date.now());
    });

    // Update device with latest data
    const lastEntry = historyData[historyData.length - 1];
    devices[deviceId].rssi = lastEntry.rssi;
    devices[deviceId].breath = lastEntry.breath;
    devices[deviceId].amps = lastEntry.amps;
    devices[deviceId].lastUpdate = Date.now();
    devices[deviceId].connected = true;

    // Update UI
    ensureDeviceGraphCards();
    updateSummary();

    // Force redraw graphs
    if (USE_OPTIMIZED) {
        markDeviceDirty(deviceId);
        scheduleRedraw();
    } else {
        drawSignalGraph(deviceId);
        drawWaveform(deviceId);
    }
}

// Update individual device data
function updateDevice(data) {
    const deviceId = data.device_id;
    const now = Date.now();

    if (!devices[deviceId]) {
        devices[deviceId] = {
            id: deviceId,
            name: data.device_name || deviceId,
            zone: data.zone || 'default',
            color: data.color || '#3fb950',
            connected: true,
        };
    }

    devices[deviceId].rssi = data.rssi;
    devices[deviceId].breath = data.breath;
    devices[deviceId].amps = data.amps;
    devices[deviceId].lastUpdate = now;
    devices[deviceId].connected = true;

    // Store history
    if (!deviceHistory[deviceId]) {
        deviceHistory[deviceId] = {
            rssi: [],
            amplitude: [],
            breathRatio: [],
            timestamps: []
        };
    }

    const hist = deviceHistory[deviceId];
    const avgAmp = data.amps ? data.amps.reduce((a, b) => a + b, 0) / data.amps.length : 0;

    hist.rssi.push(data.rssi || -100);
    hist.amplitude.push(avgAmp);
    hist.breathRatio.push((data.breath?.breath_ratio || 0) * 100);
    hist.timestamps.push(now);

    // Trim old data
    while (hist.timestamps.length > HISTORY_LENGTH) {
        hist.rssi.shift();
        hist.amplitude.shift();
        hist.breathRatio.shift();
        hist.timestamps.shift();
    }

    // Update zone presence
    const zoneId = devices[deviceId].zone;
    if (zones[zoneId]) {
        let present = 0;
        Object.values(devices).forEach(dev => {
            if (dev.zone === zoneId && dev.breath?.present) {
                present++;
            }
        });
        zones[zoneId].total_present = present;
    }

    renderZones();
    updateSummary();
    updateFloorMap();
    ensureDeviceGraphCards();

    // Mark device for redraw AFTER canvas is created (optimized mode)
    if (USE_OPTIMIZED && deviceCanvases[deviceId]) {
        markDeviceDirty(deviceId);
        scheduleRedraw();
    }
}

// Ensure device graph cards exist
function ensureDeviceGraphCards() {
    const grid = document.getElementById('deviceGraphsGrid');
    let newCardsCreated = false;

    Object.values(devices).forEach(dev => {
        if (!document.getElementById(`graph-card-${dev.id}`)) {
            createDeviceGraphCard(dev, grid);
            newCardsCreated = true;
            // Mark newly created device for redraw in OPTIMIZED mode
            if (USE_OPTIMIZED && deviceCanvases[dev.id]) {
                markDeviceDirty(dev.id);
            }
        }
        updateDeviceGraphCard(dev);
    });

    // Schedule redraw if new cards were created
    if (USE_OPTIMIZED && newCardsCreated) {
        scheduleRedraw();
    }
}

// Create device graph card
function createDeviceGraphCard(dev, container) {
    const card = document.createElement('div');
    card.id = `graph-card-${dev.id}`;
    card.className = 'device-graph-card';

    card.innerHTML = `
        <div class="device-graph-header">
            <div class="device-graph-title">
                <div class="indicator" style="background: ${dev.color}"></div>
                <span class="name">${dev.name}</span>
            </div>
            <div class="device-graph-stats">
                <span>RSSI: <span class="stat-value" id="stat-rssi-${dev.id}">--</span> dBm</span>
                <span>ÊåØÂπÖ: <span class="stat-value" id="stat-amp-${dev.id}">--</span></span>
                <span>ÂëºÂê∏: <span class="stat-value" id="stat-breath-${dev.id}">--</span>%</span>
            </div>
        </div>
        <div class="graph-container">
            <canvas id="canvas-signal-${dev.id}"></canvas>
            <div class="graph-label">‰ø°Âè∑Âº∑Â∫¶ (2ÂàÜÈñì)</div>
        </div>
        <div class="graph-container" style="height: 80px;">
            <canvas id="canvas-waveform-${dev.id}"></canvas>
            <div class="graph-label">CSIÊ≥¢ÂΩ¢ („É™„Ç¢„É´„Çø„Ç§„É†)</div>
        </div>
        <div class="graph-legend">
            <div class="graph-legend-item">
                <div class="line" style="background: var(--accent-blue)"></div>
                <span>RSSI (ÈõªÊ≥¢Âº∑Â∫¶)</span>
            </div>
            <div class="graph-legend-item">
                <div class="line" style="background: var(--accent-green)"></div>
                <span>ÊåØÂπÖ (CSIÂ§âÂãï)</span>
            </div>
            <div class="graph-legend-item">
                <div class="line" style="background: var(--accent-yellow)"></div>
                <span>ÂëºÂê∏ÊØîÁéá</span>
            </div>
        </div>
    `;

    container.appendChild(card);

    // Setup canvases
    const signalCanvas = document.getElementById(`canvas-signal-${dev.id}`);
    const waveformCanvas = document.getElementById(`canvas-waveform-${dev.id}`);

    deviceCanvases[dev.id] = {
        signal: signalCanvas,
        waveform: waveformCanvas,
        signalCtx: signalCanvas.getContext('2d'),
        waveformCtx: waveformCanvas.getContext('2d')
    };

    // Set canvas size
    resizeCanvas(signalCanvas);
    resizeCanvas(waveformCanvas);

    // Trigger initial draw for this device in OPTIMIZED mode
    if (USE_OPTIMIZED) {
        markDeviceDirty(dev.id);
    }
}

// Resize canvas to match container
function resizeCanvas(canvas) {
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
}

// Update device graph card stats
function updateDeviceGraphCard(dev) {
    const rssiEl = document.getElementById(`stat-rssi-${dev.id}`);
    const ampEl = document.getElementById(`stat-amp-${dev.id}`);
    const breathEl = document.getElementById(`stat-breath-${dev.id}`);

    if (rssiEl) rssiEl.textContent = dev.rssi || '--';
    if (ampEl) {
        const avg = dev.amps ? (dev.amps.reduce((a, b) => a + b, 0) / dev.amps.length).toFixed(1) : '--';
        ampEl.textContent = avg;
    }
    if (breathEl) {
        breathEl.textContent = dev.breath?.breath_ratio ? (dev.breath.breath_ratio * 100).toFixed(0) : '--';
    }
}

// Draw signal history graph
function drawSignalGraph(deviceId) {
    const canvasInfo = deviceCanvases[deviceId];
    const hist = deviceHistory[deviceId];
    if (!canvasInfo || !hist || hist.timestamps.length < 2) return;

    const ctx = canvasInfo.signalCtx;
    const canvas = canvasInfo.signal;
    const w = canvas.width;
    const h = canvas.height;

    // Clear
    ctx.fillStyle = '#21262d';
    ctx.fillRect(0, 0, w, h);

    // Draw grid
    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 1;
    for (let i = 1; i < 4; i++) {
        const y = (h / 4) * i;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
    }

    const padding = 5;
    const plotW = w - padding * 2;
    const plotH = h - padding * 2;

    // Normalize and draw each metric
    const drawLine = (data, color, minVal, maxVal) => {
        if (data.length < 2) return;

        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();

        for (let i = 0; i < data.length; i++) {
            const x = padding + (i / (HISTORY_LENGTH - 1)) * plotW;
            const normalized = (data[i] - minVal) / (maxVal - minVal);
            const y = padding + plotH - normalized * plotH;

            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    };

    // RSSI: -100 to -30 dBm
    drawLine(hist.rssi, '#58a6ff', -100, -30);

    // Amplitude: 0 to 100
    const maxAmp = Math.max(...hist.amplitude, 100);
    drawLine(hist.amplitude, '#3fb950', 0, maxAmp);

    // Breath ratio: 0 to 100%
    drawLine(hist.breathRatio, '#d29922', 0, 100);
}

// Draw CSI waveform
function drawWaveform(deviceId) {
    const canvasInfo = deviceCanvases[deviceId];
    const dev = devices[deviceId];
    if (!canvasInfo || !dev?.amps) return;

    const ctx = canvasInfo.waveformCtx;
    const canvas = canvasInfo.waveform;
    const w = canvas.width;
    const h = canvas.height;

    // Clear
    ctx.fillStyle = '#21262d';
    ctx.fillRect(0, 0, w, h);

    const amps = dev.amps;
    if (amps.length < 2) return;

    // Find max for scaling
    const maxAmp = Math.max(...amps, 1);

    // Draw waveform
    const isPresent = dev.breath?.present;
    ctx.strokeStyle = isPresent ? '#3fb950' : '#58a6ff';
    ctx.lineWidth = 1.5;
    ctx.beginPath();

    const padding = 5;
    for (let i = 0; i < amps.length; i++) {
        const x = padding + (i / (amps.length - 1)) * (w - padding * 2);
        const y = padding + (h - padding * 2) - (amps[i] / maxAmp) * (h - padding * 2);

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Draw presence indicator
    if (isPresent) {
        ctx.fillStyle = 'rgba(63, 185, 80, 0.3)';
        ctx.fillRect(w - 30, 5, 25, 15);
        ctx.fillStyle = '#3fb950';
        ctx.font = '10px sans-serif';
        ctx.fillText('üë§', w - 25, 16);
    }
}

// Render zone cards
function renderZones() {
    const grid = document.getElementById('zoneGrid');

    Object.entries(zones).forEach(([zoneId, zone]) => {
        let card = document.getElementById(`zone-${zoneId}`);

        if (!card) {
            card = document.createElement('div');
            card.id = `zone-${zoneId}`;
            card.className = 'zone-card';
            grid.appendChild(card);
        }

        const present = zone.total_present || 0;
        const capacity = zone.capacity || 10;
        const ratio = present / capacity;

        let statusClass, statusText;
        if (present === 0) {
            statusClass = 'empty';
            statusText = 'Á©∫„Åç';
        } else if (ratio < 0.5) {
            statusClass = 'low';
            statusText = 'Â∞ë„Å™„ÅÑ';
        } else if (ratio < 0.8) {
            statusClass = 'medium';
            statusText = '„ÇÑ„ÇÑÊ∑∑Èõë';
        } else {
            statusClass = 'high';
            statusText = 'Ê∑∑Èõë';
        }

        if (present >= (zone.alert_threshold || capacity * 0.8)) {
            card.classList.add('alert');
        } else {
            card.classList.remove('alert');
        }

        let barColor;
        if (ratio < 0.5) barColor = 'var(--accent-green)';
        else if (ratio < 0.8) barColor = 'var(--accent-yellow)';
        else barColor = 'var(--accent-red)';

        const zoneDevices = Object.values(devices).filter(d => d.zone === zoneId);

        card.innerHTML = `
            <div class="zone-header">
                <span class="zone-name">${zone.name}</span>
                <span class="zone-status ${statusClass}">${statusText}</span>
            </div>
            <div class="capacity-bar">
                <div class="capacity-fill" style="width: ${Math.min(ratio * 100, 100)}%; background: ${barColor}"></div>
                <span class="capacity-text">${present} / ${capacity}</span>
            </div>
            <div class="device-list">
                ${zoneDevices.map(dev => `
                    <div class="device-item">
                        <div class="device-indicator" style="background: ${dev.connected ? dev.color : 'var(--accent-red)'}"></div>
                        <div class="device-info">
                            <div class="device-name">${dev.name}</div>
                            <div class="device-meta">RSSI: ${dev.rssi || '--'} dBm</div>
                        </div>
                        <div class="device-status">
                            <div class="device-presence ${dev.breath?.present ? 'present' : 'absent'}">
                                ${dev.breath?.present ? 'üë§ Ê§úÂá∫' : '-- Êú™Ê§úÂá∫'}
                            </div>
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
    });
}

// Update summary
function updateSummary() {
    let totalPresent = 0;
    let activeZones = 0;
    let onlineDevices = 0;
    let alertZones = 0;

    Object.values(zones).forEach(zone => {
        const present = zone.total_present || 0;
        totalPresent += present;
        if (present > 0) activeZones++;
        if (present >= (zone.alert_threshold || zone.capacity * 0.8)) alertZones++;
    });

    Object.values(devices).forEach(dev => {
        if (dev.connected) onlineDevices++;
    });

    document.getElementById('totalPresent').textContent = totalPresent;
    document.getElementById('activeZones').textContent = activeZones;
    document.getElementById('onlineDevices').textContent = onlineDevices;
    document.getElementById('alertZones').textContent = alertZones;
    document.getElementById('deviceCount').textContent = Object.keys(devices).length;

    const totalEl = document.getElementById('totalPresent');
    totalEl.className = 'summary-value';
    if (totalPresent === 0) totalEl.classList.add('green');
    else if (alertZones > 0) totalEl.classList.add('red');
    else totalEl.classList.add('yellow');

    const banner = document.getElementById('alertBanner');
    if (alertZones > 0) {
        banner.classList.add('visible');
    } else {
        banner.classList.remove('visible');
    }
}

// Update floor map
function updateFloorMap() {
    const map = document.getElementById('floorMap');

    Object.values(devices).forEach(dev => {
        let marker = document.getElementById(`map-${dev.id}`);

        if (!marker) {
            marker = document.createElement('div');
            marker.id = `map-${dev.id}`;
            marker.className = 'map-device';
            map.appendChild(marker);
        }

        const x = 50 + (dev.position?.x || 0) * 5;
        const y = 50 + (dev.position?.y || 0) * 5;
        marker.style.left = `${x}%`;
        marker.style.top = `${y}%`;
        marker.style.borderColor = dev.color;

        const isPresent = dev.breath?.present;
        marker.className = `map-device ${isPresent ? 'present' : ''}`;

        marker.innerHTML = `
            <span class="map-device-icon">${isPresent ? 'üë§' : 'üì°'}</span>
            <span class="map-device-name">${dev.name}</span>
        `;
    });
}

// ============================================
// Performance Monitoring
// ============================================
const perfStats = {
    fps: 0,
    drawTime: 0,
    drawCalls: 0,
    wastedDraws: 0,
    longTasks: 0,
    lastFrameTime: 0,
    frameCount: 0,
    drawCallCount: 0,
    wastedDrawCount: 0,
    lastSecond: 0,
    drawTimes: [],
    isOptimized: false,
    history: []  // Â±•Ê≠¥„Çí‰øùÊåÅ
};

// Long Task Observer
if (typeof PerformanceObserver !== 'undefined') {
    try {
        const longTaskObserver = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.duration > 50) {
                    perfStats.longTasks++;
                }
            }
        });
        longTaskObserver.observe({ entryTypes: ['longtask'] });
    } catch (e) {
        console.log('Long task observer not supported');
    }
}

function togglePerfMonitor() {
    const monitor = document.getElementById('perfMonitor');
    monitor.classList.toggle('visible');
}

function updatePerfDisplay() {
    const now = performance.now();

    // Calculate FPS
    perfStats.frameCount++;
    if (now - perfStats.lastSecond >= 1000) {
        perfStats.fps = perfStats.frameCount;
        perfStats.drawCalls = perfStats.drawCallCount;
        perfStats.wastedDraws = perfStats.wastedDrawCount;

        // Average draw time
        if (perfStats.drawTimes.length > 0) {
            perfStats.drawTime = perfStats.drawTimes.reduce((a, b) => a + b, 0) / perfStats.drawTimes.length;
        }

        // Reset counters
        perfStats.frameCount = 0;
        perfStats.drawCallCount = 0;
        perfStats.wastedDrawCount = 0;
        perfStats.drawTimes = [];
        perfStats.lastSecond = now;

        // Store history
        perfStats.history.push({
            timestamp: Date.now(),
            fps: perfStats.fps,
            drawTime: perfStats.drawTime,
            drawCalls: perfStats.drawCalls,
            wastedDraws: perfStats.wastedDraws,
            longTasks: perfStats.longTasks
        });

        // Keep only last 60 seconds
        if (perfStats.history.length > 60) {
            perfStats.history.shift();
        }

        // Update display
        updatePerfUI();
    }
}

function updatePerfUI() {
    const fpsEl = document.getElementById('perfFps');
    const drawTimeEl = document.getElementById('perfDrawTime');
    const drawCallsEl = document.getElementById('perfDrawCalls');
    const wastedDrawsEl = document.getElementById('perfWastedDraws');
    const longTasksEl = document.getElementById('perfLongTasks');

    // FPS
    fpsEl.textContent = perfStats.fps;
    fpsEl.className = 'perf-monitor-value ' + (perfStats.fps >= 55 ? 'good' : perfStats.fps >= 30 ? 'warn' : 'bad');

    // Draw time
    drawTimeEl.textContent = perfStats.drawTime.toFixed(2) + ' ms';
    drawTimeEl.className = 'perf-monitor-value ' + (perfStats.drawTime < 5 ? 'good' : perfStats.drawTime < 16 ? 'warn' : 'bad');

    // Draw calls
    drawCallsEl.textContent = perfStats.drawCalls;
    drawCallsEl.className = 'perf-monitor-value ' + (perfStats.drawCalls < 30 ? 'good' : perfStats.drawCalls < 100 ? 'warn' : 'bad');

    // Wasted draws (ÊèèÁîª„Åó„Å¶„ÇÇÂ§âÂåñ„Åå„Å™„Åã„Å£„Åü„ÇÇ„ÅÆ)
    wastedDrawsEl.textContent = perfStats.wastedDraws;
    wastedDrawsEl.className = 'perf-monitor-value ' + (perfStats.wastedDraws < 10 ? 'good' : perfStats.wastedDraws < 50 ? 'warn' : 'bad');

    // Long tasks
    longTasksEl.textContent = perfStats.longTasks;
    longTasksEl.className = 'perf-monitor-value ' + (perfStats.longTasks === 0 ? 'good' : perfStats.longTasks < 5 ? 'warn' : 'bad');
}

function exportPerfData() {
    // Calculate averages from history
    if (perfStats.history.length === 0) {
        alert('„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ„Åó„Å∞„Çâ„ÅèÂæÖ„Å£„Å¶„Åã„ÇâÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
        return;
    }

    const avgFps = perfStats.history.reduce((a, b) => a + b.fps, 0) / perfStats.history.length;
    const avgDrawTime = perfStats.history.reduce((a, b) => a + b.drawTime, 0) / perfStats.history.length;
    const avgDrawCalls = perfStats.history.reduce((a, b) => a + b.drawCalls, 0) / perfStats.history.length;
    const avgWastedDraws = perfStats.history.reduce((a, b) => a + b.wastedDraws, 0) / perfStats.history.length;
    const totalLongTasks = perfStats.longTasks;

    const result = `## Performance Results (${perfStats.isOptimized ? 'OPTIMIZED' : 'ORIGINAL'})
Ê∏¨ÂÆöÊúüÈñì: ${perfStats.history.length}Áßí
„Éá„Éê„Ç§„ÇπÊï∞: ${Object.keys(devices).length}

| ÊåáÊ®ô | Âπ≥ÂùáÂÄ§ |
|------|--------|
| FPS | ${avgFps.toFixed(1)} |
| ÊèèÁîªÊôÇÈñì | ${avgDrawTime.toFixed(2)} ms |
| ÊèèÁîªÂõûÊï∞/Áßí | ${avgDrawCalls.toFixed(0)} |
| ÁÑ°ÈßÑ„Å™ÊèèÁîª/Áßí | ${avgWastedDraws.toFixed(0)} |
| Long Tasks | ${totalLongTasks} |
`;

    navigator.clipboard.writeText(result).then(() => {
        alert('ÁµêÊûú„Çí„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
    });
}

// Track last data hash for each device to detect actual changes
const lastDataHash = {};

function getDataHash(deviceId) {
    const hist = deviceHistory[deviceId];
    const dev = devices[deviceId];
    if (!hist || !dev) return '';
    return `${hist.timestamps.length}-${dev.rssi}-${dev.breath?.breath_ratio}`;
}

// Check if optimized mode is enabled via URL parameter
const USE_OPTIMIZED = new URLSearchParams(window.location.search).get('optimized') === 'true';

// Dirty flags for optimized rendering
const dirtyDevices = new Set();

// Mark device as needing redraw (called when data updates)
function markDeviceDirty(deviceId) {
    dirtyDevices.add(deviceId);
}

// ============================================
// ORIGINAL Animation Loop (for comparison)
// ============================================
function animateGraphsOriginal() {
    const frameStart = performance.now();

    Object.keys(deviceCanvases).forEach(deviceId => {
        const currentHash = getDataHash(deviceId);
        const hasChange = currentHash !== lastDataHash[deviceId];

        drawSignalGraph(deviceId);
        drawWaveform(deviceId);
        perfStats.drawCallCount += 2;

        if (!hasChange) {
            perfStats.wastedDrawCount += 2;
        }
        lastDataHash[deviceId] = currentHash;
    });

    const frameEnd = performance.now();
    perfStats.drawTimes.push(frameEnd - frameStart);

    updatePerfDisplay();
    requestAnimationFrame(animateGraphsOriginal);
}

// ============================================
// OPTIMIZED Animation Loop
// ============================================
let animationScheduled = false;

function scheduleRedraw() {
    if (!animationScheduled && dirtyDevices.size > 0) {
        animationScheduled = true;
        requestAnimationFrame(animateGraphsOptimized);
    }
}

function animateGraphsOptimized() {
    animationScheduled = false;
    const frameStart = performance.now();

    // Only redraw dirty devices
    dirtyDevices.forEach(deviceId => {
        if (deviceCanvases[deviceId]) {
            drawSignalGraphOptimized(deviceId);
            drawWaveformOptimized(deviceId);
            perfStats.drawCallCount += 2;
        }
    });
    dirtyDevices.clear();

    const frameEnd = performance.now();
    if (frameEnd - frameStart > 0) {
        perfStats.drawTimes.push(frameEnd - frameStart);
    }

    updatePerfDisplay();

    // Schedule next frame only if there's more data
    if (dirtyDevices.size > 0) {
        scheduleRedraw();
    }
}

// Optimized drawing with path caching
function drawSignalGraphOptimized(deviceId) {
    const canvasInfo = deviceCanvases[deviceId];
    const hist = deviceHistory[deviceId];
    if (!canvasInfo || !hist || hist.timestamps.length < 2) return;

    const ctx = canvasInfo.signalCtx;
    const canvas = canvasInfo.signal;
    const w = canvas.width;
    const h = canvas.height;

    // Use a single path for grid
    ctx.fillStyle = '#21262d';
    ctx.fillRect(0, 0, w, h);

    // Draw grid more efficiently
    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 1; i < 4; i++) {
        const y = (h / 4) * i;
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
    }
    ctx.stroke();

    const padding = 5;
    const plotW = w - padding * 2;
    const plotH = h - padding * 2;
    const dataLen = hist.rssi.length;
    const step = Math.max(1, Math.floor(dataLen / plotW)); // Downsample if needed

    // Draw all lines with downsampling for performance
    const drawLineOptimized = (data, color, minVal, maxVal) => {
        if (data.length < 2) return;

        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();

        let first = true;
        for (let i = 0; i < data.length; i += step) {
            const x = padding + (i / (HISTORY_LENGTH - 1)) * plotW;
            const normalized = (data[i] - minVal) / (maxVal - minVal);
            const y = padding + plotH - normalized * plotH;

            if (first) {
                ctx.moveTo(x, y);
                first = false;
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.stroke();
    };

    // RSSI
    drawLineOptimized(hist.rssi, '#58a6ff', -100, -30);

    // Amplitude
    const maxAmp = Math.max(...hist.amplitude, 100);
    drawLineOptimized(hist.amplitude, '#3fb950', 0, maxAmp);

    // Breath ratio
    drawLineOptimized(hist.breathRatio, '#d29922', 0, 100);
}

function drawWaveformOptimized(deviceId) {
    const canvasInfo = deviceCanvases[deviceId];
    const dev = devices[deviceId];
    if (!canvasInfo || !dev?.amps) return;

    const ctx = canvasInfo.waveformCtx;
    const canvas = canvasInfo.waveform;
    const w = canvas.width;
    const h = canvas.height;

    ctx.fillStyle = '#21262d';
    ctx.fillRect(0, 0, w, h);

    const amps = dev.amps;
    if (amps.length < 2) return;

    const maxAmp = Math.max(...amps, 1);
    const isPresent = dev.breath?.present;

    ctx.strokeStyle = isPresent ? '#3fb950' : '#58a6ff';
    ctx.lineWidth = 1.5;
    ctx.beginPath();

    const padding = 5;
    const plotW = w - padding * 2;
    const plotH = h - padding * 2;

    for (let i = 0; i < amps.length; i++) {
        const x = padding + (i / (amps.length - 1)) * plotW;
        const y = padding + plotH - (amps[i] / maxAmp) * plotH;

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();

    if (isPresent) {
        ctx.fillStyle = 'rgba(63, 185, 80, 0.3)';
        ctx.fillRect(w - 30, 5, 25, 15);
        ctx.fillStyle = '#3fb950';
        ctx.font = '10px sans-serif';
        ctx.fillText('üë§', w - 25, 16);
    }
}

// Select which animation loop to use
function animateGraphs() {
    if (USE_OPTIMIZED) {
        perfStats.isOptimized = true;
        document.getElementById('perfOptimized').textContent = 'OPTIMIZED';
        document.getElementById('perfOptimized').style.color = 'var(--accent-green)';
        // Initial draw for all devices
        Object.keys(deviceCanvases).forEach(markDeviceDirty);
        scheduleRedraw();
        // Set up periodic display update for stats
        setInterval(() => {
            updatePerfDisplay();
        }, 100);
    } else {
        perfStats.isOptimized = false;
        document.getElementById('perfOptimized').textContent = 'ORIGINAL';
        document.getElementById('perfOptimized').style.color = 'var(--accent-yellow)';
        animateGraphsOriginal();
    }
}

// Handle window resize
window.addEventListener('resize', () => {
    Object.values(deviceCanvases).forEach(info => {
        resizeCanvas(info.signal);
        resizeCanvas(info.waveform);
    });
    // Mark all devices dirty on resize
    if (USE_OPTIMIZED) {
        Object.keys(deviceCanvases).forEach(markDeviceDirty);
        scheduleRedraw();
    }
});

// Load hourly data from REST API
async function loadHourlyData() {
    const hours = parseInt(document.getElementById('hourlyPeriod').value);
    try {
        const response = await fetch(`${getApiUrl()}/api/v1/hourly?hours=${hours}`);
        if (!response.ok) {
            console.warn('Failed to load hourly data:', response.status);
            return;
        }
        const data = await response.json();
        displayHourlySummary(data);
    } catch (e) {
        console.warn('Failed to load hourly data:', e);
    }
}

// Display hourly summary chart
function displayHourlySummary(data) {
    if (!data || data.length === 0) {
        // Show empty state
        if (hourlyChart) {
            hourlyChart.destroy();
            hourlyChart = null;
        }
        return;
    }

    // Get selected period
    const selectedPeriod = parseInt(document.getElementById('hourlyPeriod').value);
    const currentHour = new Date().getHours();

    // Group by hour (server returns UTC, convert to local time)
    const hourlyData = {};
    for (const row of data) {
        // Parse datetime - format: "2025-12-25 06:00" (UTC)
        // Convert to local timezone
        const utcDate = new Date(row.hour.replace(' ', 'T') + ':00Z');
        const localHour = utcDate.getHours().toString().padStart(2, '0') + ':00';
        if (!hourlyData[localHour]) {
            hourlyData[localHour] = [];
        }
        // Use presence_pct which is already 0-100
        hourlyData[localHour].push(row.presence_pct || 0);
    }

    // Calculate which hours to display based on selected period
    const hours = [];
    const avgValues = [];
    const maxValues = [];

    // For periods <= 24 hours, show only relevant hours from current time backwards
    // For periods > 24 hours (48h, 168h), show all 24 hours in order (00:00-23:00)
    if (selectedPeriod > 24) {
        // Show full 24-hour range for multi-day periods
        for (let h = 0; h < 24; h++) {
            const hourStr = h.toString().padStart(2, '0') + ':00';
            hours.push(hourStr);

            if (hourlyData[hourStr]) {
                const values = hourlyData[hourStr];
                avgValues.push(values.reduce((a, b) => a + b, 0) / values.length);
                maxValues.push(Math.max(...values));
            } else {
                avgValues.push(0);
                maxValues.push(0);
            }
        }
    } else {
        // Show only relevant hours from current time backwards
        for (let i = selectedPeriod - 1; i >= 0; i--) {
            let h = (currentHour - i + 24) % 24;
            const hourStr = h.toString().padStart(2, '0') + ':00';
            hours.push(hourStr);

            if (hourlyData[hourStr]) {
                const values = hourlyData[hourStr];
                avgValues.push(values.reduce((a, b) => a + b, 0) / values.length);
                maxValues.push(Math.max(...values));
            } else {
                avgValues.push(0);
                maxValues.push(0);
            }
        }
    }

    // Destroy existing chart
    if (hourlyChart) {
        hourlyChart.destroy();
    }

    // Create new chart
    const ctx = document.getElementById('hourlyChart').getContext('2d');
    hourlyChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: hours,
            datasets: [
                {
                    label: 'Âπ≥Âùá',
                    data: avgValues,
                    backgroundColor: 'rgba(88, 166, 255, 0.6)',
                    borderColor: '#58a6ff',
                    borderWidth: 1
                },
                {
                    label: 'ÊúÄÂ§ß',
                    data: maxValues,
                    backgroundColor: 'rgba(248, 81, 73, 0.6)',
                    borderColor: '#f85149',
                    borderWidth: 1
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    title: {
                        display: true,
                        text: 'Ê∑∑ÈõëÁéá (%)',
                        color: '#8b949e'
                    },
                    grid: { color: '#30363d' },
                    ticks: { color: '#8b949e' }
                },
                x: {
                    grid: { color: '#30363d' },
                    ticks: { color: '#8b949e' }
                }
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: { color: '#e8e8e8' }
                }
            }
        }
    });
}

// Auto-refresh hourly data every 60 seconds
setInterval(() => {
    if (connected) {
        loadHourlyData();
    }
}, 60000);

// Initialize
document.getElementById('perfToggleBtn').addEventListener('click', togglePerfMonitor);
connect();
animateGraphs();
</script>
</body>
</html>
